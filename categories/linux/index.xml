<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on bon's blog</title><link>https://bonbon369.github.io/categories/linux/</link><description>Recent content in Linux on bon's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Jul 2022 21:45:07 +0800</lastBuildDate><atom:link href="https://bonbon369.github.io/categories/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Wsl2AndClash</title><link>https://bonbon369.github.io/p/wsl2andclash/</link><pubDate>Fri, 29 Jul 2022 21:45:07 +0800</pubDate><guid>https://bonbon369.github.io/p/wsl2andclash/</guid><description>&lt;h1 id="clash设置">clash设置&lt;/h1>
&lt;p>需要允许局域网连接
&lt;img src="https://bonbon369.github.io/p/wsl2andclash/pic/allowLan.png"
width="586"
height="67"
srcset="https://bonbon369.github.io/p/wsl2andclash/pic/allowLan_hu782111bbc8ea83eaf9d9158bd32a4988_3631_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2andclash/pic/allowLan_hu782111bbc8ea83eaf9d9158bd32a4988_3631_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="允许局域网连接"
class="gallery-image"
data-flex-grow="874"
data-flex-basis="2099px"
>&lt;/p>
&lt;p>以及代理端口号，这个在clash home目录的&lt;code>./profiles/xxx.yml&lt;/code>配置文件（我的文件名是一串数字）里可以看到。&lt;/p>
&lt;p>clash可以直接打开&lt;code>home/&lt;/code>目录。
&lt;img src="https://bonbon369.github.io/p/wsl2andclash/pic/HomeDirectory.png"
width="586"
height="34"
srcset="https://bonbon369.github.io/p/wsl2andclash/pic/HomeDirectory_hua8f9e214b6044e5d4abb60e5a24060f7_2259_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2andclash/pic/HomeDirectory_hua8f9e214b6044e5d4abb60e5a24060f7_2259_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="打开家目录"
class="gallery-image"
data-flex-grow="1723"
data-flex-basis="4136px"
>&lt;/p>
&lt;p>在配置文件查看端口。
&lt;img src="https://bonbon369.github.io/p/wsl2andclash/pic/port.png"
width="707"
height="257"
srcset="https://bonbon369.github.io/p/wsl2andclash/pic/port_hufb3f9eab020235db8fbfcb445abade45_22791_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2andclash/pic/port_hufb3f9eab020235db8fbfcb445abade45_22791_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="查看端口"
class="gallery-image"
data-flex-grow="275"
data-flex-basis="660px"
>&lt;/p>
&lt;h1 id="wsl设置">wsl设置&lt;/h1>
&lt;p>添加到&lt;code>~/&lt;/code>目录下的&lt;code>.bashrc&lt;/code>即可。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置clash代理&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 自动获取IP地址&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">host_ip&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>cat /etc/resolv.conf &lt;span class="p">|&lt;/span>grep &lt;span class="s2">&amp;#34;nameserver&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span>cut -d &lt;span class="s2">&amp;#34; &amp;#34;&lt;/span> -f 2&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># ALL_PROXY,应该是表示全局代理&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">export&lt;/span> &lt;span class="nv">ALL_PROXY&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;http://&lt;/span>&lt;span class="nv">$host_ip&lt;/span>&lt;span class="s2">:7890&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="自动获取ip地址">自动获取IP地址&lt;/h2>
&lt;p>&lt;code>cat /etc/resolv.conf |grep &amp;quot;nameserver&amp;quot; |cut -d &amp;quot; &amp;quot; -f 2&lt;/code>
&lt;img src="https://bonbon369.github.io/p/wsl2andclash/pic/reslov.png"
width="958"
height="86"
srcset="https://bonbon369.github.io/p/wsl2andclash/pic/reslov_hu86a4061d08eda7980d907722eadf71df_62551_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2andclash/pic/reslov_hu86a4061d08eda7980d907722eadf71df_62551_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="获取IP"
class="gallery-image"
data-flex-grow="1113"
data-flex-basis="2673px"
>&lt;/p>
&lt;h3 id="cut介绍">&lt;code>cut&lt;/code>介绍&lt;/h3>
&lt;blockquote>
&lt;p>Usage: cut OPTION&amp;hellip; [FILE]&amp;hellip;&lt;/p>
&lt;p>Use one, and only one of -b, -c or -f. Each LIST is made up of one range, or many ranges separated by commas. Selected input is written in the same order that it is read, and is written exactly once.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>cut 命令从文件的每一行（因此输出出来可能会有很多行）剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。如果不指定 File 参数，cut 命令将读取标准输入。&lt;a class="link" href="https://www.runoob.com/linux/linux-comm-cut.html" target="_blank" rel="noopener"
>&amp;ldquo;菜鸟教程&amp;rdquo;&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>因为&lt;code>grep&lt;/code>可以定位到含有关键字的行，所以cut配置grep使用的话就能输出某一行的特定字符。&lt;/p>
&lt;h4 id="参数">参数&lt;/h4>
&lt;p>&lt;code>-d&lt;/code>，自定义分隔符，默认为制表符。例如 &lt;code>-d &amp;quot; &amp;quot;&lt;/code>就是用空格来做分隔符，&lt;code>cut&lt;/code>会用分割符把内容分割成带序号的&amp;quot;区域&amp;quot;。&lt;/p>
&lt;p>&lt;code>-f&lt;/code>，这个要和&lt;code>-d&lt;/code>参数配合使用，指定显示某一个区域。分隔符是不会显示的。&lt;/p>
&lt;h2 id="命令解析">命令解析&lt;/h2>
&lt;p>首先，通过&lt;code>cat /etc/resolv.conf |grep &amp;quot;nameserver&amp;quot;&lt;/code>命令可以获得，
&lt;code>nameserver 172.19.176.1&lt;/code>
&lt;img src="https://bonbon369.github.io/p/wsl2andclash/pic/nameserver.png"
width="958"
height="219"
srcset="https://bonbon369.github.io/p/wsl2andclash/pic/nameserver_hufad6f8b0f19f53faa60d1afe55a274d7_105661_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2andclash/pic/nameserver_hufad6f8b0f19f53faa60d1afe55a274d7_105661_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="nameserver"
class="gallery-image"
data-flex-grow="437"
data-flex-basis="1049px"
>&lt;/p>
&lt;p>因为我们只想要后面的IP，所以还需要再处理一下。我们发现该字符串刚好被一个空格&lt;code>&amp;quot; &amp;quot;&lt;/code>分为了两部分，而后面一部分正是我们想要的。因此想到&lt;code>cut&lt;/code>命令并指定空格&lt;code>&amp;quot; &amp;quot;&lt;/code>为分隔符。
&lt;code>cut -d &amp;quot; &amp;quot; -f 2&lt;/code>在&lt;code>cut&lt;/code>中第二部分的序号就是2，因此用&lt;code>-f 2&lt;/code>命令来指定显示第二部分。&lt;/p>
&lt;h3 id="最后是变量">最后是变量&lt;/h3>
&lt;p>如果要用命令的输出（值）来作为bash的变量，则需要将命令写在&lt;code>$()&lt;/code>内。并且bash变量的赋值，等号两边是不能有空格的。&lt;/p>
&lt;h1 id="注意">注意&lt;/h1>
&lt;p>&lt;code>ping&lt;/code>命令不会使用代理，所以&lt;code>ping google.com&lt;/code>此时也是&lt;code>ping&lt;/code>不通的。可以使用&lt;code>curl&lt;/code>命令来测试。&lt;/p>
&lt;p>&lt;img src="https://bonbon369.github.io/p/wsl2andclash/pic/curl.png"
width="958"
height="192"
srcset="https://bonbon369.github.io/p/wsl2andclash/pic/curl_hu02f9057f375b049ed55d3438b166aec6_152548_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2andclash/pic/curl_hu02f9057f375b049ed55d3438b166aec6_152548_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="curl"
class="gallery-image"
data-flex-grow="498"
data-flex-basis="1197px"
>&lt;/p></description></item><item><title>Docker</title><link>https://bonbon369.github.io/p/docker/</link><pubDate>Sat, 07 May 2022 14:16:05 +0800</pubDate><guid>https://bonbon369.github.io/p/docker/</guid><description>&lt;img src="https://bonbon369.github.io/p/docker/contributors.png" alt="Featured image of post Docker" />&lt;p>以nginx为例。&lt;/p>
&lt;h1 id="下载并安装docker">下载并安装docker&lt;/h1>
&lt;p>&lt;a class="link" href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-convenience-script" target="_blank" rel="noopener"
>官方文档&lt;/a>，直接使用&lt;a class="link" href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-convenience-script" target="_blank" rel="noopener"
>脚本安装&lt;/a>，我选择的是Ubuntu的Docker Engine版本。
很简单我就不演示了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">curl -fsSL https://get.docker.com -o get-docker.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo bash get-docker.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#就是把.sh文件下过来,再用bash打开&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="nginx">nginx&lt;/h1>
&lt;h2 id="拉取镜像">拉取镜像&lt;/h2>
&lt;p>&lt;a class="link" href="https://hub.docker.com/_/nginx?tab=tags" target="_blank" rel="noopener"
>nginx&lt;/a>在docker上的页面。
&lt;code>sudo docker pull nginx:latest&lt;/code>&lt;/p>
&lt;h2 id="创建并启动容器">创建并启动容器&lt;/h2>
&lt;p>&lt;code>sudo docker run -d --name nginx -p 80:80 -p 443:443 nginx:latest&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>命令解析
&lt;code>run&lt;/code>：创建并运行一个容器
&lt;code>nginx:latest&lt;/code>：最后的这一条就是指定用哪一个镜像来创建容器，这里指定的就是nginx。
&lt;code>-d&lt;/code>：让容器在后台运行。
&lt;code>--name&lt;/code>：给容器命名，因为一个镜像可以开多个容器。
&lt;code>-p&lt;/code>：指定端口映射，主机端口：容器端口，例如80：88，把主机的80端口映射到docker的88端口。例如nginx会监听80端口，那我就可以指定&lt;code>-p 7474:80&lt;/code>那么&lt;code>localhost:7474&lt;/code>也会进入nginx的主页。&lt;code>-p&lt;/code>可以指定多个端口映射。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://www.runoob.com/docker/docker-run-command.html" target="_blank" rel="noopener"
>docker的其他指令&lt;/a>&lt;/p>
&lt;h1 id="进入容器内部">进入容器内部&lt;/h1>
&lt;p>&lt;code>docker exec -it nginx /bin/bash&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>exec&lt;/code>：在运行的容器中执行命令
&lt;code>-i&lt;/code>：开启标准输入，STDIN
&lt;code>-t&lt;/code>：分配一个虚拟终端，TTY
&lt;code>nginx&lt;/code>：指定容器
&lt;code>/bin/bash&lt;/code>：将这条命令放进容器里执行，就是打开bash&lt;/p>
&lt;/blockquote>
&lt;p>这样就可以在容器的内部直接操作容器了。
&lt;img src="https://bonbon369.github.io/p/docker/image1.png"
width="1692"
height="153"
srcset="https://bonbon369.github.io/p/docker/image1_hu6a059a3f68edceacff93d5c9bfb0fa1a_37351_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/docker/image1_hu6a059a3f68edceacff93d5c9bfb0fa1a_37351_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="在容器内部"
class="gallery-image"
data-flex-grow="1105"
data-flex-basis="2654px"
>&lt;/p>
&lt;h1 id="宿主机与容器共享文件">宿主机与容器共享文件&lt;/h1>
&lt;ol>
&lt;li>先创建一个nginx容器，把里面的配置文件拷贝出来。&lt;/li>
&lt;li>删除原来的nginx容器。&lt;/li>
&lt;li>在主机上创建&lt;code>www/html&lt;/code>目录，作为网站的根目录。&lt;/li>
&lt;li>新建一个nginx容器，将之前复制出来的文件和&lt;code>www/html&lt;/code>共享给nginx容器。&lt;/li>
&lt;/ol>
&lt;h2 id="准备共享的文件">准备共享的文件&lt;/h2>
&lt;h3 id="在主机上创建共享目录">在主机上创建共享目录&lt;/h3>
&lt;p>我的习惯是跟据nginx原来的目录结果，建个差不多的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo mkdir -p /mnt/nginx/html/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 网站根目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo mkdir -p /mnt/nginx/logs/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 保存日志文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo mkdir -p /mnt/nginx/conf.d/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 有一个配置文件会放在该目录下&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="拷贝配置文件">拷贝配置文件&lt;/h3>
&lt;p>先将容器中的配置文件拷贝出来，将容器nginx内的&lt;code>nginx.conf&lt;/code>和&lt;code>default.conf&lt;/code>分别复制到&lt;code>/mnt/nginx&lt;/code>和&lt;code>/mnt/nginx/conf.d/&lt;/code>目录下。
&lt;code>/mnt&lt;/code>目录是专门用来挂载的，那么将容器中的文件链接到主机，也能算挂载吧，所以放在这个目录下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo docker cp nginx:/etc/nginx/nginx.conf /mnt/nginx/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo docker cp nginx:/etc/nginx/conf.d/default.conf /mnt/nginx/conf.d/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># cp 命令如果目的地地址的末尾是个目录的话，文件会按原来的名字放进该目录。否则改成末尾的文件名。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 比如这里conf.d/是个目录，那就是将default.conf放进该目录下。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 如果去掉/符号，也就是将conf.d当作一个文件名，那么default.conf会被改名成conf.d并放在nginx/目录下&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>&lt;code>cp&lt;/code>：指定容器目录，&lt;code>[容器名或容器ID]:[容器内的目录或文件]&lt;/code>
&lt;code>cp&lt;/code>命令可以在容器和主机之间双向拷贝。&lt;/p>
&lt;/blockquote>
&lt;p>当前的目录结构&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ tree
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── conf.d
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> │   └── default.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── html
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── logs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── nginx.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="停止并移除该容器">停止并移除该容器&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo docker stop nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo docker rm nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="创建一个新的容器">创建一个新的容器&lt;/h2>
&lt;p>查看刚刚复制出来的配置文件，查看需要映射的目录，也就是日志目录、服务器根目录以及配置文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">/var/log/nginx/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#nginx的日志目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/etc/nginx/nginx.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/etc/nginx/conf.d/default.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/usr/share/nginx/html/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#服务器根目录&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>默认监听的是80端口，所以只要开一个80端口就行了。
&lt;img src="https://bonbon369.github.io/p/docker/image2.png"
width="503"
height="153"
srcset="https://bonbon369.github.io/p/docker/image2_hu2b0c6d3128588e583e7f0c4f56c673e4_19755_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/docker/image2_hu2b0c6d3128588e583e7f0c4f56c673e4_19755_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="查看端口"
class="gallery-image"
data-flex-grow="328"
data-flex-basis="789px"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo docker run &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -d --name nginx &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --restart&lt;span class="o">=&lt;/span>always &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -p 80:80 &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v /mnt/nginx/nginx.conf:/etc/nginx/nginx.conf &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v /mnt/nginx/conf.d/:/etc/nginx/conf.d/ &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v /mnt/nginx/logs/:/var/log/nginx/ &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v /mnt/nginx/html/:/usr/share/nginx/html &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --privileged nginx:latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>&lt;code>-v&lt;/code>：绑定一个卷volume，或者说主机共享目录或文件。&lt;code>[主机目录或文件]:[容器目录或文件]&lt;/code>
&lt;code>--restart&lt;/code>：这个可以设置容器的启动模式，如果一个容器被设置成设置成&lt;code>always&lt;/code>那么docker重启时，该容器也会被自动重启，总之就是保证容器一直都是开启的状态。因为服务器是要一直开着的，所以就设置为always。&lt;a class="link" href="https://docs.docker.com/config/containers/start-containers-automatically/#use-a-restart-policy" target="_blank" rel="noopener"
>文档&lt;/a>
&lt;code>--privileged&lt;/code>：授予容器所有的权限，比如写入主机目录下的文件（共享的那几个目录）。
&lt;code>\&lt;/code>：可以给命令分行&lt;/p>
&lt;/blockquote>
&lt;p>往&lt;code>/mnt/nginx/html&lt;/code>里面写一个&lt;code>index.html&lt;/code>，看看效果。&lt;/p></description></item></channel></rss>