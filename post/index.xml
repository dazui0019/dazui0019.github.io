<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on bon's blog</title><link>https://bonbon369.github.io/post/</link><description>Recent content in Posts on bon's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Jul 2022 21:45:07 +0800</lastBuildDate><atom:link href="https://bonbon369.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Wsl2 配置 Clash 代理</title><link>https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/</link><pubDate>Fri, 29 Jul 2022 21:45:07 +0800</pubDate><guid>https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/</guid><description>&lt;img src="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/clash.jpg" alt="Featured image of post Wsl2 配置 Clash 代理" />&lt;p>不是直接在虚拟机里安装&lt;a class="link" href="https://github.com/Dreamacro/clash" target="_blank" rel="noopener"
>&amp;ldquo;Clash for linux&amp;rdquo;&lt;/a>而是直接使用宿主机的clash代理，也就是只在Windows上打开代理。&lt;/p>
&lt;h1 id="clash设置">clash设置&lt;/h1>
&lt;p>需要允许局域网连接。
&lt;img src="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/allowLan.png"
width="586"
height="67"
srcset="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/allowLan_hu782111bbc8ea83eaf9d9158bd32a4988_3631_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/allowLan_hu782111bbc8ea83eaf9d9158bd32a4988_3631_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="允许局域网连接"
class="gallery-image"
data-flex-grow="874"
data-flex-basis="2099px"
>&lt;/p>
&lt;p>并获取代理端口号，这个在clash home目录的&lt;code>./profiles/xxx.yml&lt;/code>配置文件（我的文件名是一串数字）里可以看到。
clash可以直接打开&lt;code>home/&lt;/code>目录。
&lt;img src="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/HomeDirectory.png"
width="586"
height="34"
srcset="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/HomeDirectory_hua8f9e214b6044e5d4abb60e5a24060f7_2259_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/HomeDirectory_hua8f9e214b6044e5d4abb60e5a24060f7_2259_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="打开家目录"
class="gallery-image"
data-flex-grow="1723"
data-flex-basis="4136px"
>&lt;/p>
&lt;p>在配置文件中查看代理端口。
&lt;img src="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/port.png"
width="707"
height="257"
srcset="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/port_hufb3f9eab020235db8fbfcb445abade45_22791_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/port_hufb3f9eab020235db8fbfcb445abade45_22791_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="查看端口"
class="gallery-image"
data-flex-grow="275"
data-flex-basis="660px"
>&lt;/p>
&lt;p>貌似不用开启虚拟机的回环代理，实测开不开都无所谓。
&lt;img src="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/loopback.png"
width="761"
height="362"
srcset="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/loopback_hub14132ce033dd03bcaf396d167957ae6_35978_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/loopback_hub14132ce033dd03bcaf396d167957ae6_35978_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="Lookback"
class="gallery-image"
data-flex-grow="210"
data-flex-basis="504px"
>&lt;/p>
&lt;h1 id="wsl设置">wsl设置&lt;/h1>
&lt;p>添加到&lt;code>~/&lt;/code>目录下的&lt;code>.bashrc&lt;/code>即可。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 设置clash代理&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 自动获取IP地址&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">host_ip&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">$(&lt;/span>cat /etc/resolv.conf &lt;span class="p">|&lt;/span>grep &lt;span class="s2">&amp;#34;nameserver&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span>cut -d &lt;span class="s2">&amp;#34; &amp;#34;&lt;/span> -f 2&lt;span class="k">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># ALL_PROXY,应该是表示全局代理&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">export&lt;/span> &lt;span class="nv">ALL_PROXY&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;http://&lt;/span>&lt;span class="nv">$host_ip&lt;/span>&lt;span class="s2">:7890&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="自动获取ip地址">自动获取IP地址&lt;/h2>
&lt;p>&lt;code>cat /etc/resolv.conf |grep &amp;quot;nameserver&amp;quot; |cut -d &amp;quot; &amp;quot; -f 2&lt;/code>
&lt;img src="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/reslov.png"
width="958"
height="86"
srcset="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/reslov_hu86a4061d08eda7980d907722eadf71df_62551_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/reslov_hu86a4061d08eda7980d907722eadf71df_62551_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="获取IP"
class="gallery-image"
data-flex-grow="1113"
data-flex-basis="2673px"
>&lt;/p>
&lt;h3 id="cut介绍">&lt;code>cut&lt;/code>介绍&lt;/h3>
&lt;blockquote>
&lt;p>Usage: cut OPTION&amp;hellip; [FILE]&amp;hellip;&lt;/p>
&lt;p>Use one, and only one of -b, -c or -f. Each LIST is made up of one range, or many ranges separated by commas. Selected input is written in the same order that it is read, and is written exactly once.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>cut 命令从文件的每一行（因此输出出来可能会有很多行）剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。如果不指定 File 参数，cut 命令将读取标准输入。&lt;a class="link" href="https://www.runoob.com/linux/linux-comm-cut.html" target="_blank" rel="noopener"
>&amp;ldquo;菜鸟教程&amp;rdquo;&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>因为&lt;code>grep&lt;/code>可以定位到含有关键字的行，所以cut配置grep使用的话就能输出某一行的特定字符。&lt;/p>
&lt;h4 id="参数">参数&lt;/h4>
&lt;p>&lt;code>-d&lt;/code>，自定义分隔符，默认为制表符。例如 &lt;code>-d &amp;quot; &amp;quot;&lt;/code>就是用空格来做分隔符，&lt;code>cut&lt;/code>会用分割符把内容分割成带序号的&amp;quot;区域&amp;quot;。&lt;/p>
&lt;p>&lt;code>-f&lt;/code>，这个要和&lt;code>-d&lt;/code>参数配合使用，指定显示某一个区域。分隔符是不会显示的。&lt;/p>
&lt;h2 id="命令解析">命令解析&lt;/h2>
&lt;p>首先，通过&lt;code>cat /etc/resolv.conf |grep &amp;quot;nameserver&amp;quot;&lt;/code>命令可以获得，
&lt;code>nameserver 172.19.176.1&lt;/code>
&lt;img src="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/nameserver.png"
width="958"
height="219"
srcset="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/nameserver_hufad6f8b0f19f53faa60d1afe55a274d7_105661_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/nameserver_hufad6f8b0f19f53faa60d1afe55a274d7_105661_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="nameserver"
class="gallery-image"
data-flex-grow="437"
data-flex-basis="1049px"
>&lt;/p>
&lt;p>因为我们只想要后面的IP，所以还需要再处理一下。我们发现该字符串刚好被一个空格&lt;code>&amp;quot; &amp;quot;&lt;/code>分为了两部分，而后面一部分正是我们想要的。因此想到&lt;code>cut&lt;/code>命令并指定空格&lt;code>&amp;quot; &amp;quot;&lt;/code>为分隔符。
&lt;code>cut -d &amp;quot; &amp;quot; -f 2&lt;/code>在&lt;code>cut&lt;/code>中第二部分的序号就是2，因此用&lt;code>-f 2&lt;/code>命令来指定显示第二部分。&lt;/p>
&lt;h3 id="最后是变量">最后是变量&lt;/h3>
&lt;p>如果要用命令的输出（值）来作为bash的变量，则需要将命令写在&lt;code>$()&lt;/code>内。并且bash变量的赋值，等号两边是不能有空格的。&lt;/p>
&lt;h1 id="注意">注意&lt;/h1>
&lt;p>&lt;code>ping&lt;/code>命令不会使用代理，所以&lt;code>ping google.com&lt;/code>此时也是&lt;code>ping&lt;/code>不通的。可以使用&lt;code>curl&lt;/code>命令来测试。&lt;/p>
&lt;p>&lt;img src="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/curl.png"
width="958"
height="192"
srcset="https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/curl_hu02f9057f375b049ed55d3438b166aec6_152548_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/wsl2-%E9%85%8D%E7%BD%AE-clash-%E4%BB%A3%E7%90%86/pic/curl_hu02f9057f375b049ed55d3438b166aec6_152548_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="curl"
class="gallery-image"
data-flex-grow="498"
data-flex-basis="1197px"
>&lt;/p></description></item><item><title>适用于 Windows 10/11 的PL-2303HXA驱动</title><link>https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/</link><pubDate>Sun, 17 Jul 2022 14:20:26 +0800</pubDate><guid>https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/</guid><description>&lt;p>在淘宝整了一块FPGA的板子，应该是很多年前的库存了（对于我一个初学者来说，香的很!），它使用的USB转串口芯片是PL-2303HXA，但是这个型号已经停产了，所以在&lt;a class="link" href="https://www.prolific.com.tw/US/ShowProduct.aspx?pcid=41&amp;amp;showlevel=0017-0037-0041" target="_blank" rel="noopener"
>Prolific官网&lt;/a>下载的最新驱动是无法使用的（感觉是厂家故意的&amp;hellip;）。
&lt;img src="https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/pic/PL2303G.png"
width="557"
height="131"
srcset="https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/pic/PL2303G_hu1f40e2bc25c92b185ef8fe25ec2771ed_11479_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/pic/PL2303G_hu1f40e2bc25c92b185ef8fe25ec2771ed_11479_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="驱动"
class="gallery-image"
data-flex-grow="425"
data-flex-basis="1020px"
>
&lt;img src="https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/pic/discontinued.png"
width="639"
height="97"
srcset="https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/pic/discontinued_hu050c67d05a4bd9cd1b678185a260aad0_6369_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/pic/discontinued_hu050c67d05a4bd9cd1b678185a260aad0_6369_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="停产"
class="gallery-image"
data-flex-grow="658"
data-flex-basis="1581px"
>&lt;/p>
&lt;p>因此需要找到旧版的驱动，但是又不能太旧，太旧的话对Windows10以上的系统支持不太好，因此需要找到一个合适的驱动。（你废话不要太多了😡！）&lt;/p>
&lt;h2 id="下载地址">下载地址&lt;/h2>
&lt;p>&lt;a class="link" href="https://www.aliyundrive.com/s/biGJbmC8TTR" target="_blank" rel="noopener"
>阿里云&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://pan.baidu.com/s/1P5yYXq0QW7O_bsdhL9Ljiw?pwd=gec0" target="_blank" rel="noopener"
>百度云&lt;/a>&lt;/p>
&lt;h2 id="卸载驱动">卸载驱动&lt;/h2>
&lt;p>如果已经安装过驱动，安装该驱动前请先把原来的驱动删掉。具体方法如下，&lt;/p>
&lt;p>右击设备，点击&amp;quot;卸载设备&amp;quot;，在弹出的窗口中给&amp;quot;尝试删除此设备的驱动&amp;quot;打上勾。
&lt;img src="https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/pic/remove.png"
width="781"
height="572"
srcset="https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/pic/remove_hucbf3690872446adf2d3447665cc39838_49620_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/pic/remove_hucbf3690872446adf2d3447665cc39838_49620_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="卸载设备"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="327px"
>
&lt;img src="https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/pic/uninstall.png"
width="394"
height="289"
srcset="https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/pic/uninstall_hu29dac3f9da3368698cc32c053663e80c_16222_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/%E9%80%82%E7%94%A8%E4%BA%8E-windows-10/11-%E7%9A%84pl-2303hxa%E9%A9%B1%E5%8A%A8/pic/uninstall_hu29dac3f9da3368698cc32c053663e80c_16222_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="卸载驱动"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="327px"
>&lt;/p>
&lt;h2 id="安装驱动">安装驱动&lt;/h2>
&lt;p>直接双击运行。如果安装时可能还会弹出一个让你卸载驱动的窗口，按照他说的做就好了。卸载完重启一下，再重新安装。&lt;/p></description></item><item><title>Docker</title><link>https://bonbon369.github.io/p/docker/</link><pubDate>Sat, 07 May 2022 14:16:05 +0800</pubDate><guid>https://bonbon369.github.io/p/docker/</guid><description>&lt;img src="https://bonbon369.github.io/p/docker/contributors.png" alt="Featured image of post Docker" />&lt;p>以nginx为例。&lt;/p>
&lt;h1 id="下载并安装docker">下载并安装docker&lt;/h1>
&lt;p>&lt;a class="link" href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-convenience-script" target="_blank" rel="noopener"
>官方文档&lt;/a>，直接使用&lt;a class="link" href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-convenience-script" target="_blank" rel="noopener"
>脚本安装&lt;/a>，我选择的是Ubuntu的Docker Engine版本。
很简单我就不演示了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">curl -fsSL https://get.docker.com -o get-docker.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo bash get-docker.sh
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#就是把.sh文件下过来,再用bash打开&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="nginx">nginx&lt;/h1>
&lt;h2 id="拉取镜像">拉取镜像&lt;/h2>
&lt;p>&lt;a class="link" href="https://hub.docker.com/_/nginx?tab=tags" target="_blank" rel="noopener"
>nginx&lt;/a>在docker上的页面。
&lt;code>sudo docker pull nginx:latest&lt;/code>&lt;/p>
&lt;h2 id="创建并启动容器">创建并启动容器&lt;/h2>
&lt;p>&lt;code>sudo docker run -d --name nginx -p 80:80 -p 443:443 nginx:latest&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>命令解析
&lt;code>run&lt;/code>：创建并运行一个容器
&lt;code>nginx:latest&lt;/code>：最后的这一条就是指定用哪一个镜像来创建容器，这里指定的就是nginx。
&lt;code>-d&lt;/code>：让容器在后台运行。
&lt;code>--name&lt;/code>：给容器命名，因为一个镜像可以开多个容器。
&lt;code>-p&lt;/code>：指定端口映射，主机端口：容器端口，例如80：88，把主机的80端口映射到docker的88端口。例如nginx会监听80端口，那我就可以指定&lt;code>-p 7474:80&lt;/code>那么&lt;code>localhost:7474&lt;/code>也会进入nginx的主页。&lt;code>-p&lt;/code>可以指定多个端口映射。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://www.runoob.com/docker/docker-run-command.html" target="_blank" rel="noopener"
>docker的其他指令&lt;/a>&lt;/p>
&lt;h1 id="进入容器内部">进入容器内部&lt;/h1>
&lt;p>&lt;code>docker exec -it nginx /bin/bash&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>exec&lt;/code>：在运行的容器中执行命令
&lt;code>-i&lt;/code>：开启标准输入，STDIN
&lt;code>-t&lt;/code>：分配一个虚拟终端，TTY
&lt;code>nginx&lt;/code>：指定容器
&lt;code>/bin/bash&lt;/code>：将这条命令放进容器里执行，就是打开bash&lt;/p>
&lt;/blockquote>
&lt;p>这样就可以在容器的内部直接操作容器了。
&lt;img src="https://bonbon369.github.io/p/docker/image1.png"
width="1692"
height="153"
srcset="https://bonbon369.github.io/p/docker/image1_hu6a059a3f68edceacff93d5c9bfb0fa1a_37351_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/docker/image1_hu6a059a3f68edceacff93d5c9bfb0fa1a_37351_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="在容器内部"
class="gallery-image"
data-flex-grow="1105"
data-flex-basis="2654px"
>&lt;/p>
&lt;h1 id="宿主机与容器共享文件">宿主机与容器共享文件&lt;/h1>
&lt;ol>
&lt;li>先创建一个nginx容器，把里面的配置文件拷贝出来。&lt;/li>
&lt;li>删除原来的nginx容器。&lt;/li>
&lt;li>在主机上创建&lt;code>www/html&lt;/code>目录，作为网站的根目录。&lt;/li>
&lt;li>新建一个nginx容器，将之前复制出来的文件和&lt;code>www/html&lt;/code>共享给nginx容器。&lt;/li>
&lt;/ol>
&lt;h2 id="准备共享的文件">准备共享的文件&lt;/h2>
&lt;h3 id="在主机上创建共享目录">在主机上创建共享目录&lt;/h3>
&lt;p>我的习惯是跟据nginx原来的目录结果，建个差不多的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo mkdir -p /mnt/nginx/html/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 网站根目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo mkdir -p /mnt/nginx/logs/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 保存日志文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo mkdir -p /mnt/nginx/conf.d/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 有一个配置文件会放在该目录下&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="拷贝配置文件">拷贝配置文件&lt;/h3>
&lt;p>先将容器中的配置文件拷贝出来，将容器nginx内的&lt;code>nginx.conf&lt;/code>和&lt;code>default.conf&lt;/code>分别复制到&lt;code>/mnt/nginx&lt;/code>和&lt;code>/mnt/nginx/conf.d/&lt;/code>目录下。
&lt;code>/mnt&lt;/code>目录是专门用来挂载的，那么将容器中的文件链接到主机，也能算挂载吧，所以放在这个目录下。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo docker cp nginx:/etc/nginx/nginx.conf /mnt/nginx/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo docker cp nginx:/etc/nginx/conf.d/default.conf /mnt/nginx/conf.d/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># cp 命令如果目的地地址的末尾是个目录的话，文件会按原来的名字放进该目录。否则改成末尾的文件名。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 比如这里conf.d/是个目录，那就是将default.conf放进该目录下。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 如果去掉/符号，也就是将conf.d当作一个文件名，那么default.conf会被改名成conf.d并放在nginx/目录下&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>&lt;code>cp&lt;/code>：指定容器目录，&lt;code>[容器名或容器ID]:[容器内的目录或文件]&lt;/code>
&lt;code>cp&lt;/code>命令可以在容器和主机之间双向拷贝。&lt;/p>
&lt;/blockquote>
&lt;p>当前的目录结构&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ tree
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">└── nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── conf.d
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> │   └── default.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── html
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ├── logs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> └── nginx.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="停止并移除该容器">停止并移除该容器&lt;/h4>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo docker stop nginx
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">sudo docker rm nginx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="创建一个新的容器">创建一个新的容器&lt;/h2>
&lt;p>查看刚刚复制出来的配置文件，查看需要映射的目录，也就是日志目录、服务器根目录以及配置文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">/var/log/nginx/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#nginx的日志目录&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/etc/nginx/nginx.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/etc/nginx/conf.d/default.conf
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/usr/share/nginx/html/
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">#服务器根目录&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>默认监听的是80端口，所以只要开一个80端口就行了。
&lt;img src="https://bonbon369.github.io/p/docker/image2.png"
width="503"
height="153"
srcset="https://bonbon369.github.io/p/docker/image2_hu2b0c6d3128588e583e7f0c4f56c673e4_19755_480x0_resize_box_3.png 480w, https://bonbon369.github.io/p/docker/image2_hu2b0c6d3128588e583e7f0c4f56c673e4_19755_1024x0_resize_box_3.png 1024w"
loading="lazy"
alt="查看端口"
class="gallery-image"
data-flex-grow="328"
data-flex-basis="789px"
>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">sudo docker run &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -d --name nginx &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --restart&lt;span class="o">=&lt;/span>always &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -p 80:80 &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v /mnt/nginx/nginx.conf:/etc/nginx/nginx.conf &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v /mnt/nginx/conf.d/:/etc/nginx/conf.d/ &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v /mnt/nginx/logs/:/var/log/nginx/ &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> -v /mnt/nginx/html/:/usr/share/nginx/html &lt;span class="se">\
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="se">&lt;/span> --privileged nginx:latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>&lt;code>-v&lt;/code>：绑定一个卷volume，或者说主机共享目录或文件。&lt;code>[主机目录或文件]:[容器目录或文件]&lt;/code>
&lt;code>--restart&lt;/code>：这个可以设置容器的启动模式，如果一个容器被设置成设置成&lt;code>always&lt;/code>那么docker重启时，该容器也会被自动重启，总之就是保证容器一直都是开启的状态。因为服务器是要一直开着的，所以就设置为always。&lt;a class="link" href="https://docs.docker.com/config/containers/start-containers-automatically/#use-a-restart-policy" target="_blank" rel="noopener"
>文档&lt;/a>
&lt;code>--privileged&lt;/code>：授予容器所有的权限，比如写入主机目录下的文件（共享的那几个目录）。
&lt;code>\&lt;/code>：可以给命令分行&lt;/p>
&lt;/blockquote>
&lt;p>往&lt;code>/mnt/nginx/html&lt;/code>里面写一个&lt;code>index.html&lt;/code>，看看效果。&lt;/p></description></item><item><title>Hello World!</title><link>https://bonbon369.github.io/p/test-post/</link><pubDate>Sat, 07 May 2022 13:33:47 +0800</pubDate><guid>https://bonbon369.github.io/p/test-post/</guid><description>&lt;img src="https://bonbon369.github.io/p/test-post/earth.jpg" alt="Featured image of post Hello World!" />&lt;h1 id="hello-word">Hello Word!&lt;/h1>
&lt;p>你好，世界！&lt;/p></description></item></channel></rss>